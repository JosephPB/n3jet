import os
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
import random
from matplotlib import rc
import time
import pickle

from n3jet.utils.njet_run_functions import run_cc_test, run_generic_test


def generate_LO_njet(momenta, test_data):
    
    NJ_vals = []
    for i in test_data:
        vals = run_cc_test(momenta, i[1], i[2])
        NJ_vals.append(vals)
    
    # select the first test of the runs
    NJ_vals = NJ_vals[0]
    
    NJ_treevals = []
    for i in NJ_vals:
        NJ_treevals.append(i[0])
        
    return NJ_treevals 

def generate_NLO_njet(momenta, test_data, VIEW = 'NJ', k = True):
    '''
    Generates NLO virtual correction and k-factors (1-loop/born) from NJet
    :param momenta: list of 4-momenta
    :param test_data: test_data generated by run_njet(_generic)() in n3jet/utils/run_njet_functions/
    :param VIEW: 'NJ' = (1-loop*born)/born = 1-loop, 'MC' = 1-loop*born
    :param k: True returns k-factor (i.e. if VIEW = 'NJ' then returns 1-loop/born, but if 'MC' returns 1-loop)
    '''
    
    NJ_loop_vals = []
    for i in test_data:
        vals = run_generic_test(momenta, i[1], i[2], VIEW = VIEW)
        NJ_loop_vals.append(vals)
    
    # select the first test of the runs
    NJ_loop_vals = NJ_loop_vals[0][0]
        
    A0 = []
    A1_2 = []
    A1_2_error = []
    A1_1 = []
    A1_1_error = []
    A1_0 = []
    A1_0_error = []
    for i in range(len(NJ_loop_vals)):
        A0.append(NJ_loop_vals[i][0][1])
        A1_2.append(NJ_loop_vals[i][1][1])
        A1_2_error.append(NJ_loop_vals[i][1][2])
        A1_1.append(NJ_loop_vals[i][2][1])
        A1_1_error.append(NJ_loop_vals[i][2][2])
        A1_0.append(NJ_loop_vals[i][3][1])
        A1_0_error.append(NJ_loop_vals[i][3][2])
        
    NJ_treevals = np.array(A0)
    A1_0 = np.array(A1_0)

    if k == True:
        k_factor = A1_0/NJ_treevals
        return k_factor, NJ_loop_vals
    else:
        return A1_0, NJ_loop_vals
